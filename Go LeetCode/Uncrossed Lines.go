func maxUncrossedLines(nums1 []int, nums2 []int) int {
    // Получаем длины массивов nums1 и nums2
    R, C := len(nums1), len(nums2)
    // Создаем массив prev длиной C+1. Этот массив будет использоваться для хранения предыдущей строки матрицы DP.
    prev := make([]int, C+1)

    var DP []int
    // Запускаем цикл по i от 0 до R-1. В этом цикле мы будем заполнять матрицу DP по строкам.
    for i := 0; i < R; i++ {
        // Создаем массив DP длиной C+1. Этот массив будет использоваться для хранения текущей строки матрицы DP.
        DP = make([]int, C+1)

        // Запускаем цикл по j от 0 до C-1. В этом цикле мы будем заполнять текущую строку матрицы DP по столбцам.
        for j := 0; j < C; j++ {
            // Если nums1[i] == nums2[j], то мы можем нарисовать соединительную линию между этими элементами.
            if nums1[i] == nums2[j] {
                 DP[j+1] = prev[j] + 1
                // В этом случае мы устанавливаем DP[j+1] равным prev[j] + 1, где prev[j] - это значение DP[j] из предыдущей итерации цикла по j.
                } else {
                // Если nums1[i] != nums2[j], то мы не можем нарисовать соединительную линию между этими элементами.
                // Мы должны выбрать максимальное количество соединительных линий, которые можно нарисовать между первыми i элементами nums1 и первыми j-1 элементами nums2 (DP[j]), и максимальное количество соединительных линий, которые можно нарисовать между первыми i-1 элементами nums1 и первыми j элементами nums2 (prev[j+1]), и выбрать максимум из них.
                DP[j+1] = int(math.Max(float64(DP[j]), float64(prev[j+1]))) }
                }
                // Обновляем массив prev, чтобы он хранил значения DP из текущей итерации цикла по j.
                prev = DP }
    // Возвращаем значение DP[C], где C - это длина массива nums2. Это значение представляет максимальное количество соединительных линий, которые можно нарисовать между всеми элементами nums1 и nums2.
    return DP[C]
    }